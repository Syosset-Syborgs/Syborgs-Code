/*
Syborgs 10696 Autonomous Code for moving foundation
Notes:
    right strafing is good to go, while left strafing requires slower movement
*/
package org.firstinspires.ftc.teamcode;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;
public class moveFoundation_Autonomous extends LinearOpMode {
    // declare motors for mapping
    private static DcMotor frontLeftMotor, frontRightMotor, rearLeftMotor, rearRightMotor;
    private static Servo LHook, RHook;
    //convert ticks to inches
    private static final int wheelRadius = 3, length = 18, width = 18, ticksPerRev = 1440;
    private static final double ticksPerInches = (ticksPerRev)/(2 * Math.PI * wheelRadius), turnRadius = Math.sqrt(Math.pow((double) length / 2, 2) + Math.pow((double) width / 2,2 ));
    private static final double circumference = (2 * Math.PI * turnRadius);

    private void drive(int inches, double power) {
        frontLeftMotor.setTargetPosition((int) ticksPerInches * inches);
        rearLeftMotor.setTargetPosition((int) ticksPerInches * inches);
        frontRightMotor.setTargetPosition((int) ticksPerInches * inches);
        rearRightMotor.setTargetPosition((int) ticksPerInches * inches);
        frontLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        rearRightMotor.setPower(power);
        rearLeftMotor.setPower(power);
        while (frontLeftMotor.isBusy() || frontRightMotor.isBusy() || rearLeftMotor.isBusy() || rearRightMotor.isBusy());
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
        rearLeftMotor.setPower(0);
        rearRightMotor.setPower(0);
    }
    private void strafe(int inches, double power) { // default strafe right (pos values)
        frontLeftMotor.setTargetPosition((int) ticksPerInches * inches);
        rearLeftMotor.setTargetPosition((int) ticksPerInches * inches);
        frontRightMotor.setTargetPosition((int) ticksPerInches * inches);
        rearRightMotor.setTargetPosition((int) ticksPerInches * inches);
        frontLeftMotor.setPower(-power);
        frontRightMotor.setPower(power);
        rearRightMotor.setPower(-power);
        rearLeftMotor.setPower(power);
        while (frontLeftMotor.isBusy() || frontRightMotor.isBusy() || rearLeftMotor.isBusy() || rearRightMotor.isBusy());
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
        rearLeftMotor.setPower(0);
        rearRightMotor.setPower(0);
    }
    private void turnLeft(int degrees, double power) {
        frontLeftMotor.setTargetPosition((int) turnRadius * degrees);
        rearLeftMotor.setTargetPosition((int) turnRadius * degrees);
        frontRightMotor.setTargetPosition((int) turnRadius * degrees);
        rearRightMotor.setTargetPosition((int) turnRadius * degrees);
        frontLeftMotor.setPower(-power);
        frontRightMotor.setPower(power);
        rearRightMotor.setPower(power);
        rearLeftMotor.setPower(-power);
        while (frontLeftMotor.isBusy() || frontRightMotor.isBusy() || rearLeftMotor.isBusy() || rearRightMotor.isBusy());
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
        rearLeftMotor.setPower(0);
        rearRightMotor.setPower(0);
    }

    // initialize
    @Override
    public void runOpMode() throws InterruptedException {
        // map motors
        frontLeftMotor = hardwareMap.get(DcMotor.class, "frontLeft");
        frontRightMotor = hardwareMap.get(DcMotor.class, "frontRight");
        rearLeftMotor = hardwareMap.get(DcMotor.class, "rearLeft");
        rearRightMotor = hardwareMap.get(DcMotor.class, "rearRight");
        // run encoders for motors
        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rearLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rearRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        // reset encoders for motors
        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rearLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rearRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        // get into position
        frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rearLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rearRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        //BRAKE when at zero power
        frontLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        rearLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        rearRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        // reverse directions for the two sides
        frontLeftMotor.setDirection(DcMotorSimple.Direction.FORWARD);
        rearLeftMotor.setDirection(DcMotorSimple.Direction.FORWARD);
        frontRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        rearRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        // map hooks
        LHook = hardwareMap.get(Servo.class, "LHook");
        RHook = hardwareMap.get(Servo.class, "RHook");
        waitForStart();
        while (opModeIsActive()) {
            /**
             * goals: (starting after driving past bridge
             * turn left to let hooks face foundation
             * back into it, hook it, and strafe left slowly to give space between wall and foundation
             * turn left again, strafe right into parking zone
             * back foundation into the wall
             * unhook
             */
            turnLeft(90, .6);
            drive(24, -.6);
            LHook.setPosition(1);
            RHook.setPosition(1);
            strafe(6, -0.6);
            turnLeft(90, .6);
            strafe(28, .6);
            LHook.setPosition(.5);
            RHook.setPosition(.5);




            telemetry.addData("front Left Motor: ", frontLeftMotor.getCurrentPosition());
            telemetry.addData("front Right Motor: ", frontRightMotor.getCurrentPosition());
            telemetry.addData("rear Left Motor: ", rearLeftMotor.getCurrentPosition());
            telemetry.addData("rear Right Motor", rearRightMotor.getCurrentPosition());
            
            telemetry.update();
        }
    }
}

