package org.firstinspires.ftc.teamcode;
import org.firstinspires.ftc.robotcore.external.ClassFactory;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;
import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;
import com.vuforia.HINT;
import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.vuforia.Vuforia;
import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import java.util.ArrayList;



public class VuforiaCode extends LinearOpMode {
   private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;
   private static final boolean PHONE_IS_PORTRAIT = false;
   private static VuforiaLocalizer.CameraDirection cameraDir;
   private static String trackablesFile;
   private static final float mmPerInch = 25.4f;
   private static final float stoneZ = 2.00f * mmPerInch;
   WebcamName webcamName;
   VuforiaTrackables visionTargets;
   VuforiaTrackable target;
   OpenGLMatrix lastKnownLocation;
   OpenGLMatrix phoneLocation;
   VuforiaTrackableDefaultListener listener;
   private OpenGLMatrix lastLocation = null;
   private VuforiaLocalizer vuforia;
   private static final float bridgeZ = 6.42f * mmPerInch;
   private static final float bridgeY = 23 * mmPerInch;
   private static final float bridgeX = 5.18f * mmPerInch;
   private static final float bridgeRotY = 59;                                 // Units are degrees
   private static final float bridgeRotZ = 180;

   // Constants for perimeter targets
   private static final float halfField = 72 * mmPerInch;
   private static final float quadField = 36 * mmPerInch;
   private static final float mmTargetHeight = (6) * mmPerInch;

   public OpenGLMatrix createMatrix(float x, float y, float z, float u, float v, float w) {
       return OpenGLMatrix.translation(x, y, z).multiplied(Orientation.getRotationMatrix(AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES, u, v, w));
   }

   public String formatMatrix(OpenGLMatrix matrix) {
       return matrix.formatAsTransform();
   }

   public void FtcVuforia() {
       this.cameraDir = cameraDir;
       //
       // If no camera view ID, do not activate camera monitor view to save power.
       //
       VuforiaLocalizer.Parameters params = new VuforiaLocalizer.Parameters();
       params.vuforiaLicenseKey = "ATsODcD/////AAAAAVw2lR...d45oGpdljdOh5LuFB9nDNfckoxb8COxKSFX";
       params.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;
       params.useExtendedTracking = false;

       VuforiaLocalizer localizer = ClassFactory.getInstance().createVuforia(params);
       visionTargets = localizer.loadTrackablesFromAsset("FTC_2019-20");
       VuforiaTrackables targetsSkyStone = this.vuforia.loadTrackablesFromAsset("Skystone");
       target = visionTargets.get(0);
       target.setName("Stone Target");
       VuforiaTrackable target = targetsSkyStone.get(0);
       VuforiaTrackable blueRearBridge = targetsSkyStone.get(1);
       blueRearBridge.setName("Blue Rear Bridge");
       VuforiaTrackable redRearBridge = targetsSkyStone.get(2);
       redRearBridge.setName("Red Rear Bridge");
       VuforiaTrackable redFrontBridge = targetsSkyStone.get(3);
       redFrontBridge.setName("Red Front Bridge");
       VuforiaTrackable blueFrontBridge = targetsSkyStone.get(4);
       blueFrontBridge.setName("Blue Front Bridge");
       VuforiaTrackable red1 = targetsSkyStone.get(5);
       red1.setName("Red Perimeter 1");
       VuforiaTrackable red2 = targetsSkyStone.get(6);
       red2.setName("Red Perimeter 2");
       VuforiaTrackable front1 = targetsSkyStone.get(7);
       front1.setName("Front Perimeter 1");
       VuforiaTrackable front2 = targetsSkyStone.get(8);
       front2.setName("Front Perimeter 2");
       VuforiaTrackable blue1 = targetsSkyStone.get(9);
       blue1.setName("Blue Perimeter 1");
       VuforiaTrackable blue2 = targetsSkyStone.get(10);
       blue2.setName("Blue Perimeter 2");
       VuforiaTrackable rear1 = targetsSkyStone.get(11);
       rear1.setName("Rear Perimeter 1");
       VuforiaTrackable rear2 = targetsSkyStone.get(12);
       rear2.setName("Rear Perimeter 2");
       VuforiaTrackables allTrackables = (VuforiaTrackables) new ArrayList<VuforiaTrackable>();
       target.setLocation(OpenGLMatrix
               .translation(0, 0, stoneZ)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));

       //Set the position of the bridge support targets with relation to origin (center of field)

       blueFrontBridge.setLocation(OpenGLMatrix
               .translation(-bridgeX, bridgeY, bridgeZ)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 0, bridgeRotY, bridgeRotZ)));

       blueRearBridge.setLocation(OpenGLMatrix
               .translation(-bridgeX, bridgeY, bridgeZ)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 0, -bridgeRotY, bridgeRotZ)));

       redFrontBridge.setLocation(OpenGLMatrix
               .translation(-bridgeX, -bridgeY, bridgeZ)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 0, -bridgeRotY, 0)));

       redRearBridge.setLocation(OpenGLMatrix
               .translation(bridgeX, -bridgeY, bridgeZ)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 0, bridgeRotY, 0)));

       //Set the position of the perimeter targets with relation to origin (center of field)
       red1.setLocation(OpenGLMatrix
               .translation(quadField, -halfField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));

       red2.setLocation(OpenGLMatrix
               .translation(-quadField, -halfField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));

       front1.setLocation(OpenGLMatrix
               .translation(-halfField, -quadField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));

       front2.setLocation(OpenGLMatrix
               .translation(-halfField, quadField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));

       blue1.setLocation(OpenGLMatrix
               .translation(-quadField, halfField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));

       blue2.setLocation(OpenGLMatrix
               .translation(quadField, halfField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));

       rear1.setLocation(OpenGLMatrix
               .translation(halfField, quadField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));

       rear2.setLocation(OpenGLMatrix
               .translation(halfField, -quadField, mmTargetHeight)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));
       target.setLocation(OpenGLMatrix
               .translation(0, 0, stoneZ)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));
       float phoneYRotate = 0;
       float phoneXRotate = 0;
       float phoneZRotate = 0;
       if (CAMERA_CHOICE == BACK) {
           phoneYRotate = -90;
       } else {
           phoneYRotate = 90;
       }

       // Rotate the phone vertical about the X axis if it's in portrait mode
       if (PHONE_IS_PORTRAIT) {
           phoneXRotate = 90;
       }


       final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center
       final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground
       final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line

       OpenGLMatrix robotFromCamera = OpenGLMatrix
               .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)
               .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));
       while (!isStopRequested()) {
           for (VuforiaTrackable trackable : allTrackables) {
               ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, params.cameraDirection);
               if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {
                   telemetry.addData("Visible Target", trackable.getName());
                   boolean targetVisible = true;

                   // getUpdatedRobotLocation() will return null if no new information is available since
                   // the last time that call was made, or if the trackable is not currently visible.
                   OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();
                   if (robotLocationTransform != null) lastLocation = robotLocationTransform;
                   break;
               }
           }


           phoneLocation = createMatrix(0, 225, 0, 90, 0, 0);
           listener = (VuforiaTrackableDefaultListener) target.getListener();
           listener.setPhoneInformation(phoneLocation, params.cameraDirection);

       }
       float robotX = 0;
       float robotY;
       robotY = 0;
       float robotAngle = 0;
       boolean targetVisible = false;

       public void runOpMode() throws InterruptedException {
           webcamName = hardwareMap.get(WebcamName.class, "Webcam 1");
           int cameraMonitorViewId;
           cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
           VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);
           parameters.cameraDirection = CAMERA_CHOICE;
           FtcVuforia();
           lastKnownLocation = createMatrix(0, 0, 0, 0, 0, 0);
           waitForStart();
           visionTargets.activate();
           Vuforia.setHint(HINT.HINT_MAX_SIMULTANEOUS_IMAGE_TARGETS, 4);
           while (opModeIsActive()) {
               OpenGLMatrix latestLocation = listener.getUpdatedRobotLocation();
               if (latestLocation != null) {
                   lastKnownLocation = latestLocation;
               }
               float[] coordinates = lastKnownLocation.getTranslation().getData();
               robotX = coordinates[0];
               robotY = coordinates[1];
               robotAngle = Orientation.getOrientation(lastKnownLocation, AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES).thirdAngle;
               telemetry.addData("Tracking" + target.getName(), listener.isVisible());
               telemetry.addData("Last Known Location", formatMatrix(lastKnownLocation));
           }


       }


   }
}


